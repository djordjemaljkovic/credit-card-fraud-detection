# -*- coding: utf-8 -*-
"""knn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16llv6h57vamu1OldFiaPs_am0Td4BbHy
"""

#Potrebne biblioteke

from math import sqrt
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import RobustScaler
from sklearn import metrics
from sklearn.metrics import precision_score, recall_score, f1_score, roc_auc_score, accuracy_score, classification_report
from sklearn.metrics import average_precision_score, precision_recall_curve
import matplotlib
import matplotlib.pyplot as plt
from matplotlib import rcParams
import matplotlib.gridspec as gridspec
from IPython.core.pylabtools import figsize
import seaborn as sns
import time
from collections import Counter
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import StratifiedKFold
from sklearn.model_selection import cross_val_score
from imblearn.over_sampling import SMOTE
from decimal import *
import warnings

#Postavljanje formata ispisa

rcParams['figure.figsize'] = 12,5
colors = ["#0101DF", "#DF0101"]
pd.options.display.float_format = "{:,.5f}".format
pd.set_option("display.max_columns", None)
pd.set_option('display.max_colwidth', None)
pd.set_option('display.max_rows', None)
warnings.filterwarnings('ignore')

from google.colab import files
uploaded = files.upload()


#Ucitavanje i ispis seta podataka

df=pd.read_csv('creditcard.csv')
pd.set_option('display.max_columns',None)
pd.set_option('display.expand_frame_repr', False)
print("Izgled seta podataka: \n")
print(df.head())
print("\n")
print("Dimenzije seta podataka: \n")
print(df.shape)
print("\n")
print("Kolone u setu podataka: \n")
print(df.columns)
print("\n")
print("Informacije o setu podataka: \n")
print(df.info)
print("\n")
print("Statistički podaci: \n")
print(df.describe())
print("\n")
print("Provera podataka koje nedostaju: \n")
print(df.isnull().sum().max())
print("\n")
print("Provera dupliranih vrednosti: \n")
print(df.duplicated().sum())
print("\n")







#Provera dupliranih vrednosti u setu podataka

ddf=df[df.duplicated()]
print(ddf.shape)
print(df[df.duplicated(keep=False)].head())

ddfsum = ddf[ddf["Class"]==1]['Class'].sum()
total = len(df[df['Class']==1])
duptotal = round((ddfsum/total)*100,2)
print("Dupliciranih vrednosti za nevalidnu transakciju {} je oko {} % od ukupno {} vrednosti.".format(ddfsum,duptotal,total))
print("Uklanjanje dupliciranih vrednosti.")
df.drop_duplicates(inplace=True, ignore_index=True)
print(df.loc[df.duplicated(),:])

#Odnos validnih i nevalidnih transakcija
ratio = df['Class'].value_counts()/len(df.index)
print(df['Class'].value_counts())
print(len(df.index))
print(ratio)

#Funckija gustine raspodele izlazne varijable

sns.countplot('Class', data=df)
plt.title('FGV izlazne varijable (0: validna transakcija || 1: nevalidna transakcija)', fontsize=12)

#Funckija gustine raspodele izlazne varijable

plt.pie(df.Class.value_counts(),labels=['Validna transakcija','Nevalidna transakcija'],startangle=180,autopct='%.3f');

#Vremenska analiza svih transakcija

print ("Nevalidna transakcija")
print (df.Time[df.Class == 1].describe())
print ()
print ("Validna transakcija")
print (df.Time[df.Class == 0].describe())

#Histogramski prikaz

f, (ax1, ax2) = plt.subplots(2, 1, sharex=True, figsize=(12,4))
bins = 50
ax1.hist(df.Time[df.Class == 1], bins = bins)
ax1.set_title('Nevalidna transakcija')
ax2.hist(df.Time[df.Class == 0], bins = bins)
ax2.set_title('Validna transakcija')
plt.xlabel('Vreme [s]')
plt.ylabel('Broj transakcija')
plt.show()

#Odnos tipa transakcije i svote novca

f, axes = plt.subplots(ncols=2)
sns.boxplot(x="Class", y="Amount", data=df, palette=colors, ax=axes[0],showfliers=True)
axes[0].set_title('Zavisnost tipa transkacije i vrednosti transakcije')
sns.boxplot(x="Class", y="Amount", data=df, palette=colors, ax=axes[1],showfliers=False)
axes[1].set_title('Zavisnost tipa transakcije i vrednosti transakcije bez graničnih odbiraka')
plt.show()

#Odnos tipa transakcije i vremena transakcije

f, axes = plt.subplots(ncols=2)
sns.boxplot(x="Class", y="Time", data=df, palette=colors, ax=axes[0],showfliers=True)
axes[0].set_title('Tip transkacije vs Vreme transakcije')
sns.boxplot(x="Class", y="Time", data=df, palette=colors, ax=axes[1],showfliers=False)
axes[1].set_title('Tip transkacije vs Vreme transakcije bez graničnih odbiraka')
plt.show()

#Funckije gustine raspodele svote novca i vremena transkacije

fig, ax = plt.subplots(1, 2, figsize=(18,4))
amount_val = df['Amount'].values
time_val = df['Time'].values
sns.distplot(amount_val, ax=ax[0], color='b')
ax[0].set_title('Raspodela vrednosti transakcija', fontsize=14)
ax[0].set_xlim([min(amount_val), max(amount_val)])
sns.distplot(time_val, ax=ax[1], color='r')
ax[1].set_title('Raspodela vremena transakcija', fontsize=14)
ax[1].set_xlim([min(time_val), max(time_val)])
plt.show()

#Multivarijabilna analiza

df1=df[df['Class']==1]
df2=df[df['Class']==0]
fig, ax = plt.subplots(1,2, figsize=(15, 5))

ax[0].scatter(df1['Time'],df1['Amount'],color='red', marker= '*', label='Nevalidno')
ax[0].set_title('Vreme transakcije vs vrednost transakcije')
ax[0].legend(bbox_to_anchor =(0.25, 1.15))

ax[1].scatter(df2['Time'],df2['Amount'],color='green', marker= '.', label='Validno')
ax[1].set_title('Vreme transakcije vs vrednost transakcije')
ax[1].legend(bbox_to_anchor =(0.3, 1.15))

plt.show();

sns.lmplot(x='Time', y='Amount', hue='Class', markers=['x', 'o'], data=df, height=6);

g = sns.FacetGrid(df, col="Class", height=6)
g.map(sns.scatterplot, "Time", "Amount", alpha=.7)
g.add_legend();

sns.heatmap(
    df.loc[:, ['Amount', 'Time', 'Class']].corr(),
    annot=True
);

sns.set(font_scale=1.15)
plt.figure(figsize=(16,8))
sns.heatmap(df.corr(), cmap='RdBu_r', vmin=-1, vmax=1);





#Funckije raspodela obeležja

var = df.columns.values

i = 0
t0 = df.loc[df['Class'] == 0]
t1 = df.loc[df['Class'] == 1]

sns.set_style('whitegrid')
plt.figure()
fig, ax = plt.subplots(8,4,figsize=(16,28))

for feature in var[0:-1]:
    i += 1
    plt.subplot(8,4,i)
    sns.kdeplot(t0[feature], bw=0.5,label="Class = 0")
    sns.kdeplot(t1[feature], bw=0.5,label="Class = 1")
    plt.xlabel(feature, fontsize=12, labelpad=-4)
    locs, labels = plt.xticks()
    plt.tick_params(axis='both', which='major', labelsize=12)
plt.show();



#Histogrami obeležja

colval = var[1:29]
len(colval)

plt.figure(figsize=(12,28*4))
gs = gridspec.GridSpec(28, 1)
for i, cn in enumerate(df[colval]):
    ax = plt.subplot(gs[i])
    sns.distplot(df[cn][df.Class == 1], bins=50)
    sns.distplot(df[cn][df.Class == 0], bins=50)
    ax.set_xlabel('')
    ax.set_title('Histogram obeležja: ' + str(cn))
plt.show()



#Normiranje vrednosti obeležja

rob_scaler = RobustScaler()

df['scaled_amount'] = rob_scaler.fit_transform(df['Amount'].values.reshape(-1,1))
df['scaled_time'] = rob_scaler.fit_transform(df['Time'].values.reshape(-1,1))

df.drop(['Time','Amount'], axis=1, inplace=True)
df.head()

#Preraspodela obeležja

scaled_amount = df['scaled_amount']
scaled_time = df['scaled_time']

df.drop(['scaled_amount', 'scaled_time'], axis=1, inplace=True)
df.insert(0, 'scaled_amount', scaled_amount)
df.insert(1, 'scaled_time', scaled_time)
print(df.head())
print(df.describe())
print('Validne transakcije čine', round(df['Class'].value_counts()[0]/len(df) * 100,2), ' % seta podataka')
print('Nevalidne transakcije čine', round(df['Class'].value_counts()[1]/len(df) * 100,2), ' % seta podataka')

#Stanardizacija obeležja

X = df.drop('Class', axis=1)
y = df['Class']

skf = StratifiedKFold(n_splits=5, random_state=None, shuffle=False)

for train_index, test_index in skf.split(X, y):
    print("Train:", train_index, "Test:", test_index)
    original_Xtrain, original_Xtest = X.iloc[train_index], X.iloc[test_index]
    original_ytrain, original_ytest = y.iloc[train_index], y.iloc[test_index]

#Stvaranje nizova

original_Xcombined = pd.concat([original_Xtrain, original_Xtest])
original_ycombined = pd.concat([original_ytrain, original_ytest])
original_Xtrain = original_Xtrain.values
original_Xtest = original_Xtest.values
original_ytrain = original_ytrain.values
original_ytest = original_ytest.values
original_Xcombined = original_Xcombined.values
original_ycombined = original_ycombined.values


#Provera da li su sva obeležja jednako raspodeljena

train_unique_label, train_counts_label = np.unique(original_ytrain, return_counts=True)
test_unique_label, test_counts_label = np.unique(original_ytest, return_counts=True)

print('\n Raspodele : \n')
print("Obučavajući skup: ")
print(train_counts_label/ len(original_ytrain))
print("Testirajući skup: ")
print(test_counts_label/ len(original_ytest))

#Ispis obučavajućeg i testirajućeg skupa

print('Broj elemenata u X (train): {} | Broj elemenata u Y (train): {}'.format(len(original_Xtrain), len(original_ytrain)))
print('Broj elemenata u X (test): {} | Broj elemenata u Y (test): {}'.format(len(original_Xtest), len(original_ytest)))

from matplotlib.colors import ListedColormap
def plot_decision_regions(X,y,classifier,test_idx = None, resolution=0.02):
  markers = ('o','s','^','v','<')
  colors = ('red','blue','lightgreen','gray','cyan')
  cmap = ListedColormap(colors[:len(np.unique(y))])

  x1_min, x1_max = X[:,0].min()-1, X[:,0].max()+1
  x2_min, x2_max = X[:,1].min()-1, X[:,1].max()+1

  xx1 , xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution),
                          np.arange(x2_min,x2_max, resolution))
  lab = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T)
  lab = lab.reshape(xx1.shape)
  plt.contourf(xx1,xx2,lab,alpha=0.3,cmap=cmap)
  plt.xlim(xx1.min(), xx1.max())
  plt.ylim(xx2.min(), xx2.max())

  #iscrtavanje klasa
  for idx, cl in enumerate(np.unique(y)):
    plt.scatter(x=X[y == cl, 0],
                y=X[y == cl, 1],
                alpha=0.8,
                c=colors[idx],
                marker=markers[idx],
                label=f'Class {cl}',
                edgecolor='black')

  #isticanje klasa
  if test_idx:
    X_test,y_test = X[test_idx, :], y[test_idx]
    plt.scatter(X_test[:,0],X_test[:,1],c='none',edgecolor='black',alpha=1.0,
                linewidth=1,marker='o', s=100,label="Testirajući skup")

#KNN - bez upotrebe SMOTE za nebalansirane setove podataka

knn=KNeighborsClassifier(n_neighbors=5)
knn.fit(original_Xtrain,original_ytrain)
y_knn=knn.predict(original_Xtest)
y_knn_prob=knn.predict_proba(original_Xtest)[:,1]
model_comparison = {}

print("Matrica konfuzije:\n",metrics.confusion_matrix(original_ytest,y_knn))
print("Accuracy:",metrics.accuracy_score(original_ytest,y_knn))
print("Precision:",metrics.precision_score(original_ytest,y_knn))
print("Recall:",metrics.recall_score(original_ytest,y_knn))
print("F1-Score:",metrics.f1_score(original_ytest,y_knn))
print("AUC:",metrics.roc_auc_score(original_ytest,y_knn))
accuracies = cross_val_score(estimator = knn, X = original_Xtrain, y = original_ytrain, cv = 5)
print("Cross Val Accuracy: {:.2f} %".format(accuracies.mean()*100))
print("Cross Val Standard Deviation: {:.2f} %".format(accuracies.std()*100))
model_comparison['KNN']=[accuracy_score(original_ytest,y_knn),
                         f1_score(original_ytest,y_knn,average='weighted'),
                         (accuracies.mean()),(accuracies.std())]

auc=metrics.roc_auc_score(original_ytest,y_knn)
fpr,tpr,thresholds=metrics.roc_curve(original_ytest,y_knn_prob)
plt.plot(fpr,tpr,'b', label='AUC = %0.2f'% auc)
plt.plot([0,1],[0,1],'r-.')
plt.xlim([-0.2,1.2])
plt.ylim([-0.2,1.2])
plt.title('Receiver Operating Characteristic\nKNN')
plt.legend(loc='lower right')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.show()

#SMOTE

sm=SMOTE(sampling_strategy='minority', random_state=42)
X_sm,y_sm=sm.fit_resample(original_Xtrain,original_ytrain)
print(X_sm.shape,y_sm.shape)
print(len(y_sm[y_sm==1]),len(y_sm[y_sm==0]))

#KNN - uz SMOTE za nebalansirane setove podataka

knn=KNeighborsClassifier(n_neighbors=51)
knn.fit(X_sm, y_sm)
y_knn_smote=knn.predict(original_Xtest)
y_knn_smote_prob=knn.predict_proba(original_Xtest)[:,1]

print("Matrica konfuzije:\n",metrics.confusion_matrix(original_ytest,y_knn_smote))
print("Accuracy:",metrics.accuracy_score(original_ytest,y_knn_smote))
print("Precision:",metrics.precision_score(original_ytest,y_knn_smote))
print("Recall:",metrics.recall_score(original_ytest,y_knn_smote))
print("F1-Score:",metrics.f1_score(original_ytest,y_knn_smote))
print("AUC:",metrics.roc_auc_score(original_ytest,y_knn_smote))
accuracies_smote = cross_val_score(estimator = knn, X = X_sm, y = y_sm, cv = 5)
print("Cross Val Accuracy: {:.2f} %".format(accuracies_smote.mean()*100))
print("Cross Val Standard Deviation: {:.2f} %".format(accuracies_smote.std()*100))
model_comparison['KNN k=51 & SMOTE']=[accuracy_score(original_ytest,y_knn_smote),
                         f1_score(original_ytest,y_knn_smote,average='weighted'),
                         (accuracies_smote.mean()),(accuracies_smote.std())]

auc=metrics.roc_auc_score(original_ytest,y_knn_smote)
fpr,tpr,thresholds=metrics.roc_curve(original_ytest,y_knn_smote_prob)
plt.plot(fpr,tpr,'b', label='AUC = %0.2f'% auc)
plt.plot([0,1],[0,1],'r-.')
plt.xlim([-0.2,1.2])
plt.ylim([-0.2,1.2])
plt.title('Receiver Operating Characteristic\nKNN')
plt.legend(loc='lower right')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.show()



#Pregled uspešnosti modela

Model_com_df=pd.DataFrame(model_comparison).T
Model_com_df.columns=['Model Accuracy','Model F1-Score','CV Accuracy','CV std']
Model_com_df=Model_com_df.sort_values(by='Model F1-Score',ascending=False)
Model_com_df.style.format("{:.2%}").background_gradient(cmap='Blues')